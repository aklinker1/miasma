// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// AppConfig app config
//
// swagger:model AppConfig
type AppConfig struct {

	// A list of other apps that the service communicates with using their service name and docker's internal DNS. Services don't have to be two way; only the service that accesses the other needs the other network added
	// Unique: true
	Networks []string `json:"networks"`

	// The placement constraints specifying which nodes the application will be ran on. Any valid value for the [`--constraint` flag](https://docs.docker.com/engine/swarm/services/#placement-constraints) is valid item in this list
	// Unique: true
	Placement []string `json:"placement"`

	// The ports that you access the application through in the swarm. This field can, and should be left empty. Miasma automatically manages assigning published ports between 3001-4999. If you need to specify a port, make sure it's outside that range or the port has not been taken. Plugins have set ports starting with 4000, so avoid 4000-4020 if you want to add a plugin at a later date. If these ports are ever cleared, the app will continue using the same ports it was published to before, so that the ports don't change unnecessarily. If you removed it to clear a port for another app/plugin, make sure to restart the app and a new, random port will be allocated for the app, freeing the old port
	// Unique: true
	PublishedPorts []int64 `json:"publishedPorts"`

	// route
	Route *AppConfigRoute `json:"route,omitempty"`

	// The ports that the application is listening to inside the container. If no target ports are specified, then the container should respect the `PORT` env var.
	// Unique: true
	TargetPorts []int64 `json:"targetPorts"`
}

// Validate validates this app config
func (m *AppConfig) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateNetworks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePlacement(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePublishedPorts(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRoute(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTargetPorts(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AppConfig) validateNetworks(formats strfmt.Registry) error {

	if swag.IsZero(m.Networks) { // not required
		return nil
	}

	if err := validate.UniqueItems("networks", "body", m.Networks); err != nil {
		return err
	}

	return nil
}

func (m *AppConfig) validatePlacement(formats strfmt.Registry) error {

	if swag.IsZero(m.Placement) { // not required
		return nil
	}

	if err := validate.UniqueItems("placement", "body", m.Placement); err != nil {
		return err
	}

	return nil
}

func (m *AppConfig) validatePublishedPorts(formats strfmt.Registry) error {

	if swag.IsZero(m.PublishedPorts) { // not required
		return nil
	}

	if err := validate.UniqueItems("publishedPorts", "body", m.PublishedPorts); err != nil {
		return err
	}

	return nil
}

func (m *AppConfig) validateRoute(formats strfmt.Registry) error {

	if swag.IsZero(m.Route) { // not required
		return nil
	}

	if m.Route != nil {
		if err := m.Route.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("route")
			}
			return err
		}
	}

	return nil
}

func (m *AppConfig) validateTargetPorts(formats strfmt.Registry) error {

	if swag.IsZero(m.TargetPorts) { // not required
		return nil
	}

	if err := validate.UniqueItems("targetPorts", "body", m.TargetPorts); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *AppConfig) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AppConfig) UnmarshalBinary(b []byte) error {
	var res AppConfig
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// AppConfigRoute When the Traefik plugin is installed, the route describes where the app can be accessed from.
//
// swagger:model AppConfigRoute
type AppConfigRoute struct {

	// Describes the hostname the application is served at ("test.domain.com")
	Host *string `json:"host,omitempty"`

	// The path at a given host the application can be reached from ("/api"). It should start with a "/"
	Path *string `json:"path,omitempty"`

	// Instead of using `host` and/or `path`, you can specify the exact rule Traefik will use to route to the application. See [Traefik's documentation]() for how to use this field. This field takes priority over `host` and `path`
	TraefikRule *string `json:"traefikRule,omitempty"`
}

// Validate validates this app config route
func (m *AppConfigRoute) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *AppConfigRoute) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AppConfigRoute) UnmarshalBinary(b []byte) error {
	var res AppConfigRoute
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
