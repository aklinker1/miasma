// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// RunConfig All the properties that define how the application runs in docker
//
// swagger:model RunConfig
type RunConfig struct {

	// The ID of the app the run config is for
	// Required: true
	// Format: uuid4
	AppID strfmt.UUID4 `json:"appId" gorm:"primaryKey"`

	// command
	Command []string `json:"command"`

	// The currently running image digest (hash). Used internally when running applications
	// instead of the tag because the when a new image is pushed, the tag stays the same but the
	// digest changes
	//
	// Required: true
	ImageDigest string `json:"imageDigest"`

	// A list of other apps that the service communicates with using their service name and docker's internal DNS. Services don't have to be two way; only the service that accesses the other needs the other network added
	// Unique: true
	Networks []string `json:"networks"`

	// The placement constraints specifying which nodes the app will be ran on. Any valid value for the [`--constraint` flag](https://docs.docker.com/engine/swarm/services/#placement-constraints) is valid item in this list
	// Unique: true
	Placement []string `json:"placement"`

	// The ports that you access the app through in the swarm. This field can, and should be left empty. Miasma automatically manages assigning published ports between 3001-4999. If you need to specify a port, make sure it's outside that range or the port has not been taken. Plugins have set ports starting with 4000, so avoid 4000-4020 if you want to add a plugin at a later date. If these ports are ever cleared, the app will continue using the same ports it was published to before, so that the ports don't change unnecessarily. If you removed it to clear a port for another app/plugin, make sure to restart the app and a new, random port will be allocated for the app, freeing the old port
	// Unique: true
	PublishedPorts []uint32 `json:"publishedPorts"`

	// The ports that the app is listening to inside the container. If no target ports are specified, then the container should respect the `PORT` env var.
	// Unique: true
	TargetPorts []uint32 `json:"targetPorts"`

	// volume bindings for the app
	Volumes []*RunConfigVolumesItems0 `json:"volumes"`
}

// Validate validates this run config
func (m *RunConfig) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAppID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateImageDigest(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNetworks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePlacement(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePublishedPorts(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTargetPorts(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVolumes(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RunConfig) validateAppID(formats strfmt.Registry) error {

	if err := validate.Required("appId", "body", strfmt.UUID4(m.AppID)); err != nil {
		return err
	}

	if err := validate.FormatOf("appId", "body", "uuid4", m.AppID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *RunConfig) validateImageDigest(formats strfmt.Registry) error {

	if err := validate.RequiredString("imageDigest", "body", string(m.ImageDigest)); err != nil {
		return err
	}

	return nil
}

func (m *RunConfig) validateNetworks(formats strfmt.Registry) error {

	if swag.IsZero(m.Networks) { // not required
		return nil
	}

	if err := validate.UniqueItems("networks", "body", m.Networks); err != nil {
		return err
	}

	return nil
}

func (m *RunConfig) validatePlacement(formats strfmt.Registry) error {

	if swag.IsZero(m.Placement) { // not required
		return nil
	}

	if err := validate.UniqueItems("placement", "body", m.Placement); err != nil {
		return err
	}

	return nil
}

func (m *RunConfig) validatePublishedPorts(formats strfmt.Registry) error {

	if swag.IsZero(m.PublishedPorts) { // not required
		return nil
	}

	if err := validate.UniqueItems("publishedPorts", "body", m.PublishedPorts); err != nil {
		return err
	}

	return nil
}

func (m *RunConfig) validateTargetPorts(formats strfmt.Registry) error {

	if swag.IsZero(m.TargetPorts) { // not required
		return nil
	}

	if err := validate.UniqueItems("targetPorts", "body", m.TargetPorts); err != nil {
		return err
	}

	return nil
}

func (m *RunConfig) validateVolumes(formats strfmt.Registry) error {

	if swag.IsZero(m.Volumes) { // not required
		return nil
	}

	for i := 0; i < len(m.Volumes); i++ {
		if swag.IsZero(m.Volumes[i]) { // not required
			continue
		}

		if m.Volumes[i] != nil {
			if err := m.Volumes[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("volumes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *RunConfig) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *RunConfig) UnmarshalBinary(b []byte) error {
	var res RunConfig
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// RunConfigVolumesItems0 run config volumes items0
//
// swagger:model RunConfigVolumesItems0
type RunConfigVolumesItems0 struct {

	// The volume name or directory on the host that the data is stored in
	Source string `json:"Source,omitempty"`

	// The path inside the container that the data is served from
	Target string `json:"Target,omitempty"`
}

// Validate validates this run config volumes items0
func (m *RunConfigVolumesItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *RunConfigVolumesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *RunConfigVolumesItems0) UnmarshalBinary(b []byte) error {
	var res RunConfigVolumesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
