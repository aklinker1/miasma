// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// AppConfig app config
//
// swagger:model AppConfig
type AppConfig struct {

	// Whether or not the app shows up by default when listing the apps
	Hidden bool `json:"hidden,omitempty"`

	// The docker image the app runs
	Image string `json:"image,omitempty"`

	// A list of other apps that the service communicates with using their service name and docker's internal DNS. Services don't have to be two way; only the service that accesses the other needs the other network added
	// Unique: true
	Networks []string `json:"networks"`

	// The placement constraints specifying which nodes the app will be ran on. Any valid value for the [`--constraint` flag](https://docs.docker.com/engine/swarm/services/#placement-constraints) is valid item in this list
	// Unique: true
	Placement []string `json:"placement"`

	// The ports that you access the app through in the swarm. This field can, and should be left empty. Miasma automatically manages assigning published ports between 3001-4999. If you need to specify a port, make sure it's outside that range or the port has not been taken. Plugins have set ports starting with 4000, so avoid 4000-4020 if you want to add a plugin at a later date. If these ports are ever cleared, the app will continue using the same ports it was published to before, so that the ports don't change unnecessarily. If you removed it to clear a port for another app/plugin, make sure to restart the app and a new, random port will be allocated for the app, freeing the old port
	// Unique: true
	PublishedPorts []int64 `json:"publishedPorts"`

	// route
	Route *AppConfigRoute `json:"route,omitempty"`

	// The ports that the app is listening to inside the container. If no target ports are specified, then the container should respect the `PORT` env var.
	// Unique: true
	TargetPorts []int64 `json:"targetPorts"`

	// volume bindings for the app
	Volumes []*AppConfigVolumesItems0 `json:"volumes"`
}

// Validate validates this app config
func (m *AppConfig) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateNetworks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePlacement(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePublishedPorts(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRoute(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTargetPorts(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVolumes(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AppConfig) validateNetworks(formats strfmt.Registry) error {

	if swag.IsZero(m.Networks) { // not required
		return nil
	}

	if err := validate.UniqueItems("networks", "body", m.Networks); err != nil {
		return err
	}

	return nil
}

func (m *AppConfig) validatePlacement(formats strfmt.Registry) error {

	if swag.IsZero(m.Placement) { // not required
		return nil
	}

	if err := validate.UniqueItems("placement", "body", m.Placement); err != nil {
		return err
	}

	return nil
}

func (m *AppConfig) validatePublishedPorts(formats strfmt.Registry) error {

	if swag.IsZero(m.PublishedPorts) { // not required
		return nil
	}

	if err := validate.UniqueItems("publishedPorts", "body", m.PublishedPorts); err != nil {
		return err
	}

	return nil
}

func (m *AppConfig) validateRoute(formats strfmt.Registry) error {

	if swag.IsZero(m.Route) { // not required
		return nil
	}

	if m.Route != nil {
		if err := m.Route.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("route")
			}
			return err
		}
	}

	return nil
}

func (m *AppConfig) validateTargetPorts(formats strfmt.Registry) error {

	if swag.IsZero(m.TargetPorts) { // not required
		return nil
	}

	if err := validate.UniqueItems("targetPorts", "body", m.TargetPorts); err != nil {
		return err
	}

	return nil
}

func (m *AppConfig) validateVolumes(formats strfmt.Registry) error {

	if swag.IsZero(m.Volumes) { // not required
		return nil
	}

	for i := 0; i < len(m.Volumes); i++ {
		if swag.IsZero(m.Volumes[i]) { // not required
			continue
		}

		if m.Volumes[i] != nil {
			if err := m.Volumes[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("volumes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *AppConfig) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AppConfig) UnmarshalBinary(b []byte) error {
	var res AppConfig
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// AppConfigRoute When the Traefik plugin is installed, the route describes where the app can be accessed from.
//
// swagger:model AppConfigRoute
type AppConfigRoute struct {

	// Describes the hostname the app is served at ("test.domain.com")
	Host *string `json:"host,omitempty"`

	// The path at a given host the app can be reached from ("/api"). It should start with a "/"
	Path *string `json:"path,omitempty"`

	// Instead of using `host` and/or `path`, you can specify the exact rule Traefik will use to route to the app. See [Traefik's documentation]() for how to use this field. This field takes priority over `host` and `path`
	TraefikRule *string `json:"traefikRule,omitempty"`
}

// Validate validates this app config route
func (m *AppConfigRoute) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *AppConfigRoute) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AppConfigRoute) UnmarshalBinary(b []byte) error {
	var res AppConfigRoute
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// AppConfigVolumesItems0 app config volumes items0
//
// swagger:model AppConfigVolumesItems0
type AppConfigVolumesItems0 struct {

	// The volume name or directory on the host that the data is stored in
	Source string `json:"Source,omitempty"`

	// The path inside the container that the data is served from
	Target string `json:"Target,omitempty"`
}

// Validate validates this app config volumes items0
func (m *AppConfigVolumesItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *AppConfigVolumesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AppConfigVolumesItems0) UnmarshalBinary(b []byte) error {
	var res AppConfigVolumesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
